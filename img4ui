#!/bin/bash

# Check if ImageMagick is installed
if ! command -v convert &> /dev/null; then
    echo "Error: ImageMagick (convert) is not installed."
    exit 1
fi

# Ensure input file and variable name are provided
if [ $# -lt 2 ]; then
    echo "Usage: $0 <input_file> <variable_name>"
    exit 1
fi

# Input file and variable name setup
INPUT_FILE="$1"
VARIABLE_NAME="$2"
OUTPUT_FILE="${VARIABLE_NAME}.ui"

# Reduce colors to 16 with optimized palette
# make sure we have a MAGENTA bg (-background '#ff00ff')
# turn pixels with alpha shading either on or off (-channel A -fx "(a>0.5) ? 1.0 : 0")
# remove any transparency layer (-flatten)
# make sure we have a paletted image (-type palette)
# make sure our bitmap is XX colors (-colors "$numColors")
# turn *off* dithering: +dither
# remapping the palette is done by cvtpcx!
#-define png:format=png8
convert $INPUT_FILE -colors 16 -depth 4 -type palette +dither \
        -define png:color-type=3 \
        -define png:bit-depth=4 \
        reduced.png

identify -verbose reduced.png

# Extract width and height
WIDTH=$(identify -format "%w" reduced.png)
HEIGHT=$(identify -format "%h" reduced.png)

# Begin writing the .ui file
{
    echo "visMoniker ${VARIABLE_NAME} = {"
    echo "    size = standard;"
    echo "    style = icon;"
    echo "    aspectRatio = normal;"
    echo "    color = color4;"
    echo "    cachedSize = $WIDTH, $HEIGHT;"
    echo "    gstring {"
    echo "        GSBeginString"
    echo "        GSFillBitmapAtCP <(${VARIABLE_NAME}End - ${VARIABLE_NAME}Start)>"
    echo "        ${VARIABLE_NAME}Start	label	byte"
    echo "        CBitmap <<$WIDTH,$HEIGHT,BMC_UNCOMPACTED,BMF_4BIT or mask BMT_PALETTE or mask BMT_COMPLEX>, 0, $HEIGHT, 0, 70, 20, 72, 72>"
    echo "        word    16"
} > "$OUTPUT_FILE"

# Extract and append palette data
convert reduced.png -format "%c" histogram:info:- | awk '
/#[0-9A-Fa-f]{6}/ {
    match($0, /#[0-9A-Fa-f]{6}/, color)
    r = substr(color[0], 2, 2)
    g = substr(color[0], 4, 2)
    b = substr(color[0], 6, 2)
    printf "        RGBValue < 0x%s, 0x%s, 0x%s >\n", tolower(r), tolower(g), tolower(b)
}' | head -n 16 > palette.tmp
convert reduced.png -format "%c" histogram:info:-

# Ensure there are exactly 16 palette entries, padding if necessary
awk 'BEGIN {
    for (i = 1; i <= 16; i++) {
        palette[i] = "        RGBValue < 0x00, 0x00, 0x00 >"
    }
}
{
    palette[NR] = $0
}
END {
    for (i = 1; i <= 16; i++) {
        print palette[i]
    }
}' palette.tmp >> "$OUTPUT_FILE"

# Insert a newline
echo "" >> "$OUTPUT_FILE"


# Extract and remap pixel data to ensure indices are constrained to 0–15
convert reduced.png -depth 8 gray:- | xxd -p -c "$((WIDTH / 2))" | LC_ALL=C awk '
{
    for (i = 1; i <= length($0); i += 2) {
        # Map each 8-bit value to a 4-bit value (0–15)
        byte = strtonum("0x" substr($0, i, 2)) % 16
        printf "%01x", byte
        if (i % 32 == 0) printf "\n"  # Wrap lines to match the image width
    }
}' > pixel_data_remapped.txt


# Generate `db` lines from the remapped pixel data
cat pixel_data_remapped.txt | awk -v width="$((WIDTH / 2))" '
{
    printf "        db  "
    for (i = 1; i <= length($0); i += 2) {
        byte = substr($0, i, 2)
        printf "0x%s", byte
        if (i < length($0) - 1) printf ", "
    }
    printf "\n"
}' >> "$OUTPUT_FILE"

#convert reduced.png -depth 4 gray:- | xxd -p -c "$((WIDTH / 2))" | awk '
#{
#    printf "        db  "
#    for (i = 1; i <= length($0); i += 2) {
#        byte = substr($0, i, 2)
#        printf "0x%s", byte
#        if (i < length($0) - 1) printf ", "
#    }
#    printf "\n"
#}' >> "$OUTPUT_FILE"

convert reduced.png -depth 4 gray:- | xxd -p -c "$WIDTH"

# Add the variable name end label and close the .ui file
{
    echo "        ${VARIABLE_NAME}End    label    byte"
    echo "        GSEndString"
    echo "    }"
    echo "}"
} >> "$OUTPUT_FILE"

# Clean up intermediate files
rm reduced.png palette.tmp

echo "Conversion complete. Output written to $OUTPUT_FILE."